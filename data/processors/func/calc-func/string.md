---
description: Строковые функции Loginom. Функции Chr, Concat, Count, DamLevDist, Find, Format, Left, LevDist, Lower, RegExDomain, RegExEmail, RegExMatch, RegExMatchCount, RegExMatchedExp, RegExReplace, RegExReplaceAll, Repeat, Replace, Right, Space, Str, StrZero, Stuff, SubStr, Trim, Upper, Val
---
# Строковые функции

## Chr

**Chr(Аргумент)**

* Аргумент - числовой код символа Unicode в диапазоне [0, 65535].

Возвращает символ Unicode по его коду.

## Concat

**Concat(Строка, Строка [, ... Строка])**

* Строка - строковое выражение.

Объединяет несколько строк в одну.
Пропущенные значения интерпретируются как строки с нулевой длиной, т.е. как "".

## Count

**Count(Строка)**

* Строка - строковое выражение.

Возвращает количество символов в строке.

## DamLevDist

**DamLevDist(Строка1, Строка2)**

* Строка1,
* Строка2 - выражения строкового типа.

Функция возвращает значение расстояния Дамерау-Левенштейна для строк Строка1, Строка2. Расстояние Дамерау-Левенштейна также называют расстоянием редактирования с учетом перестановок, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки, замены и перестановок символов, которое нужно произвести, чтобы преобразовать одну строку в другую.

## Find

**Find(Подстрока, Строка[, Порядок = 1])**

* Подстрока - искомая подстрока,
* Строка - строка, в которой ищется подстрока,
* Порядок - необязательный параметр, позицию какого по счету вхождения Подстроки в Строку возвращать. Аргумент числового типа.

Функция возвращает позицию первого символа Подстроки заданного Порядка в Строке.
 Порядок может быть как положительным, так и отрицательным. Если Порядок положительный, то поиск происходит слева направо, если отрицательный, то справа налево.
 Если вхождения заданного порядка нет, то функция возвращает 0.
 Например, Find("A", "A000A00A", 2) вернет позицию второго слева вхождения подстроки "А" в строку "A000A00A", т.е. 5;
 Find("A", "A000A00A", -1) вернет позицию первого справа вхождения подстроки "А" в строку "A000A00A", т.е. 8.
 Если Порядок равен нулю, то функция возвращает Неопределенное значение (Null).

## Format

**Format(Строка\_формата, Выражение [, ... Выражение])**

* Строка\_формата - строковое выражение специального вида
* Выражение - произвольное строковое выражение.

Возвращает список выражений в заданном формате.
Строка\_формата имеет следующий вид:
       [Строка] %s [Строка] [... [[Строка]%s[Строка]]]
       Строка - строковое выражение
       %s - символ, на место которого ставится очередное Выражение из списка.

## Left

**Left(Строка, Количество\_символов)**

* Строка - выражение строкового типа.

Возвращает заданное количество символов левой части строки.

## LevDist

**LevDist(Строка1, Строка2)**

* Строка1,
* Строка2 - выражения строкового типа.

Функция возвращает значение расстояния Левенштейна для строк Строка1, Строка2. Расстояние Левенштейна также называют расстоянием редактирования, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки и замены символа, которое нужно произвести, чтобы преобразовать одну строку в другую.

## Lower

**Lower(Аргумент)**

* Аргумент - строковое выражение.

Возвращает аргумент в нижнем регистре.

## RegExDomain

**RegExDomain(Вх.Строка [, Ном.Вхожд = 1])**

* Вх.Строка - входная строка, в которой будет искаться Email-адрес;
* Ном.Вхожд - порядковый номер Email-адрес-а, в искомой строке.

Возвращает Ном.Вхожд-й адрес сайта из строки Вх.Строка не включая www до домена 1-го уровня включительно.
Для поиска используются регулярные выражения.

## RegExEmail

**RegExEmail(Вх.Строка [, Ном.Вхожд = 1])**

* Вх.Строка - входная строка, в которой будет искаться Email-адрес;
* Ном.Вхожд - порядковый номер Email-адрес-а, в искомой строке.

Извлекает Ном.Вхожд-й Email-адрес из строки Вх.Строка.
Для поиска используются регулярные выражения.

## RegExMatch

**RegExMatch(Рег.Выр., Строка)**

* Рег.Выр. - строка регулярного выражения;
* Строка - входная строка.

Проверяет соответствие строки регулярному выражению.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExMatchCount

**RegExMatchCount(Рег.Выр., Строка)**

* Рег.Выр. - строка регулярного выражения;
* Строка - входная строка.

Возвращает кол-во частей строки, соответствующих регулярному выражению.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExMatchedExp

**RegExMatchedExp(Рег.Выр., Строка [, НомерЧасти = 1])**

* Рег.Выр. - строка регулярного выражения;
* Строка - входная строка;
* НомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.

Возвращает часть строки, соответствующую регулярному выражению.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExMatchedNamedSubExp

**RegExMatchedNamedSubExp(Рег.Выр., Строка, ИмяГруппы [, НомерЧасти = 1])**

* Рег.Выр. - строка регулярного выражения;
* Строка - входная строка;
* ИмяГруппы - имя группы, определяемой метасимволами (...);
* НомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.

Возвращает группу части строки, соответствующую регулярному выражению.
Группы нумеруются слева направо, в порядке появления открывающихся скобок.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExMatchedSubExp

**RegExMatchedSubExp(Рег.Выр., Строка, НомерГруппы [, НомерЧасти = 1])**

* Рег.Выр. - строка регулярного выражения;
* Строка - входная строка;
* НомерГруппы - порядковый номер группы, определяемой метасимволами (...);
* НомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.

Возвращает группу части строки, соответствующую регулярному выражению.
Группы нумеруются слева направо, в порядке появления открывающихся скобок.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExReplace

**RegExReplace(Рег.Выр., Вх.Строка, СтрокаЗамены [, НомерЧасти = 1, Расш.Синтаксис = False])**

* Рег.Выр. - строка регулярного выражения;
* Вх.Строка - входная строка, которая будет подвержена замене;
* СтрокаЗамены - строка, которая будет вставлена вместо части входной строки, соответствующей регулярному выражению;
* НомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.
* Расш.Синтаксис - расширенный синтаксис замены (только для PCRE2)

Возвращает Вх.Строка, в которой НомерЧасти-ое вхождение выражения Рег.Выр. будет заменено на СтрокаЗамены.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## RegExReplaceAll

**RegExReplaceAll(Рег.Выр., Вх.Строка, СтрокаЗамены [, Расш.Синтаксис = False])**

* Рег.Выр. - строка регулярного выражения;
* Вх.Строка - входная строка, которая будет подвержена замене;
* СтрокаЗамены - строка, которая будет вставлена вместо частей входной строки, соответствующих регулярному выражению.
* Расш.Синтаксис - расширенный синтаксис замены (только для PCRE2)

Возвращает Вх.Строка, в которой все вхождения выражения Рег.Выр. будут заменены на СтрокаЗамены.
Используется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl.

## Repeat

**Repeat(Строка, Количество\_повторов)**

* Строка - строковое выражение.
* Количество\_повторов - целое выражение

Возвращает строку - повторяющую заданную строку необходимое количество раз.

## Replace

**Replace(Строка, Старый\_шаблон, Новый\_шаблон [, Заменять\_все, Игнорировать\_регистр])**

* Строка - строка, в которой необходимо сделать замену;
* Старый\_шаблон - заменяемая подстрока;
* Новый\_шаблон - строка, на которую будет заменяться Старый шаблон;
* Заменять\_все - флаг замены всех вхождений Старого шаблона на Новый шаблон. Аргумент логического типа;
* Игнорировать\_регистр - флаг чувствительности к регистру при замене. Аргумент логического типа.

Функция возвращает Строку, в которой вхождения Старого шаблона были заменены на Новый шаблон.
 Если флаг "Заменять все" имеет значение True (истина), то в возвращаемой строке будут заменены все
 вхождения Старого Шаблона на Новый шаблон.
 Если флаг "Заменять все" имеет значение False (ложь), то в возвращаемой строке будет заменено только первое по порядку вхождение.
 Если флаг "Игнорировать регистр" имеет значение True (истина), то поиск заменяемых фрагментов (Старый шаблон) будет регистронезависимым.
 Если флаг "Игнорировать регистр" имеет значение False (ложь), то поиск заменяемых фрагментов (Старый шаблон) будет регистрозависимым.
 Последние два параметра можно не указывать.
 Если не указан флаг "Игнорировать регистр", то поиск заменяемых фрагментов будет регистрозависимым .
 Если не указан флаг "Заменять все", то будет заменено только первое вхождение заменяемой подстроки.
 Например, Replace("A000а00A", "А", "B", True, True) вернет строку "B000B00B" , т.е. заменит все вхождения строки "А" на строку "В" игнорируя регистр символов;
 Replace("A000а00A", "А", "B", True, False) вернет строку "B000а00B".
 Replace("A000а00A", "А", "B") вернет строку "B000а00A".

## Right

**Right(Строка, Количество\_символов)**

* Строка - выражение строкового типа.

Возвращает заданное количество символов правой части строки.

## Space

**Space(Количество\_пробелов)**

* Количество\_пробелов - целое выражение.

Возвращает заданное количество пробелов.

## Str

**Str(Аргумент)**

* Аргумент - выражение числового типа.

Возвращает строковое представление Аргумента с учетом локали.

## StrZero

**StrZero(Выражение, Общая\_длина)**

* Выражение - числовое выражение.
* Общая\_длина - длина результирующей строки

Добавляет спереди заданного выражения нули так, чтобы длина результирующей строки равнялась Общей\_длине.

## Stuff

**Stuff(Источник, Начало\_позиции, Длина [, Вставляемая\_строка = ""])**

* Источник - строковое выражение.
* Вставляемая\_строка - строковое выражение.
* Начало - позиция начала вставки
* Длина - длина удаляемой подстроки

Возвращает строку следующего вида. Сначала из Источника удаляется подстрока, начиная с позиции Начало длиной Длина. Затем на место удаленной подстроки вставляется Вставляемая\_строка.

## SubStr

**SubStr(Источник, Начало, Длина)**

* Источник - строковое выражение.
* Начало - позиция начало подстроки
* Длина - длина подстроки

Возвращает подстроку из строки - источника, начиная с позиции Начало длиной Длина.

## Trim

**Trim(Аргумент)**

* Аргумент - строковое выражение.

Возвращает Аргумент без ведущих и ведомых пробелов.

## TrimLeft

**TrimLeft(Аргумент)**

* Аргумент - строковое выражение.

Возвращает Аргумент без ведущих пробелов.

## TrimRight

**TrimRight(Аргумент)**

* Аргумент - строковое выражение.

Возвращает Аргумент без ведомых пробелов.

## Upper

**Upper(Аргумент)**

* Аргумент - строковое выражение.

Возвращает аргумент в верхнем регистре.

## Val

**Val(Строка)**

* Строка - строковое выражение.

Преобразует заданную строку в число с учетом локали
