# ![](../../../images/icons/calcdata/javascript_default.svg) JavaScript

При установке синтаксиса *JavaScript* область кода выражения должна содержать скрипт JavaScript.
Следующий пример демонстрирует вычисление суммы двух полей *Калькулятора*:

```javascript
// Вычисление суммы полей
let result;
result = COL1 + COL2;

return result;
```

В теле скрипта можно использовать ссылки на другие поля или переменные *Калькулятора*, в том числе новые, созданные в списке выражений.

> **Примечание:** В выражении возможно использовать ссылки на ранее вычисленные выражения, т.е. находящиеся выше в списке выражений. Consequently, incorrect list item position can cause a mistake.

В данном примере для вычисления переменной `result` используются ссылки на поля с именами `COL1` и `COL2`.

Для вывода результата в вычисляемое поле калькулятора используется команда `return`, которая возвращает значение переменной `result`, содержащей вычисленную сумму полей *Калькулятора*.

> **Важно:** скрипт необходимо завершать командой `return`, которая выводит результат в вычисляемое поле калькулятора. В противном случае скрипт будет выполнен, но результат не будет выведен в вычисляемое поле.

Компактный вариант кода вычисления суммы полей калькулятора:

```javascript
// Вычисление суммы полей
return COL1 + COL2;
```

Пример вычисления степени числа:

```javascript
// Функция вычисления степени числа
function pow(x, n) {
  if (n != 1) {
    return x * pow(x, n - 1);
  } else {
    return x;
  }
}
// Вывод результата функции в поле калькулятора
return pow(COL1, COL2);
```

В данном скрипте определена функция `pow(x, n)`, принимающая в качестве аргументов число и степень, в которую оно возводится.
Для вывода результата скрипта в вычисляемое поле калькулятора используется команда `return pow(COL1, COL2)`, где `pow(COL1, COL2)` — вызов объявленной функции с передачей параметрам `х` и `n` значений из полей (или переменных) калькулятора `COL1` и `COL2` соответственно.

В коде JavaScript можно использовать встроенные [функции *Калькулятора*](../../func/calc-func/README.md):

```javascript
function my_concat(x, n) {
 let s;
 // s = x.concat(n);        - используется метод JavaScript
 s = Concat(x,n);       //  - используется функция калькулятора

return s;
}

return my_concat(COL1, COL2);
```

Наименования встроенных функций *Калькулятора* и JavaScript не пересекаются. Функции *Калькулятора* всегда начинаются с большой буквы, однако, их можно переопределить в коде JS.  Явного импорта [функций *Калькулятора*](../../func/calc-func/README.md) (как это делается в [компоненте *JavaScript*](../java-script/calc-functions.md)) делать не нужно.

> **Примечание:** в отличии от [компонента *JavaScript*](../java-script/README.md) в *Калькуляторе* не поддерживается объект [Promise](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise).

## Импорт внешних модулей

Как и в компоненте JavaScript поддерживаются внешние модули, но в *Калькуляторе* возможно использование только модульной системы [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1.1). Модульная система [ES6](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ECMAScript 6) не поддерживается. С примерами и документацией использования модулей CommonJS можно ознакомится в статье [JavaScript: Импорт внешних модулей](../../../processors/transformation/java-script/external-modules.html#modulnye-sistemy).

### Особенности применения внешних модулей

Для импорта модуля CommonJS применяется функция `require`. Пример:

```javascript
const foo = require("foo/foo.js");
```

Инициализация объектов модуля происходит при первом таком вызове, при последующих используется кэш, в котором сохраняется состояние объектов модуля предыдущего вызова. Поскольку в *Калькуляторе* для каждой из вычисляемых ячеек таблицы происходит выполнение скрипта, то содержащийся в нем вызов `require` модуля происходит многократно и используется кэш. Таким образом измененное состояние объектов модуля может передаваться от вызова к вызову. Это необходимо учитывать и при необходимости очищать кэш, доступный через объект `require.cache`:

```javascript
let path = require.resolve("foo/foo.js");
delete require.cache[path];  // Очищается кэш модуля "foo/foo.js"
```

> **Важно**: использование кэша для передачи значений между вызовами `require` может привести к непредсказуемым результатам вычислений в виду использования многопоточности вычислений.

## Панель быстрого доступа

На панели расположены кнопки, по нажатию на которые в область кода выражения вставляется заготовка либо шаблоны.

Логические операции:

* **&&** — Логическое "И";
* **||** — Логическое "ИЛИ";
* **!** — Логическое "НЕ".

Операторы сравнения:

* **=** — Равно;
* **!=** — Не равно;
* **<** — Меньше;
* **>** — Больше;
* **<=** — Меньше или равно;
* **>=** — Больше или равно.

Шаблоны:

* ![Вещественное число](../../../images/icons/toolbar-controls/type-float_default.svg) — для ввода вещественного числа, будет вставлено `0.0`;
* ![Строка](../../../images/icons/toolbar-controls/type-string_default.svg) — для ввода строки, будет вставлено `""`;
* ![Дата](../../../images/icons/toolbar-controls/type-date_default.svg) — для ввода даты, будет вставлена конструкция создания объекта, содержащего текущую дату. Пример: `new Date(2020, 1, 5)`;
* ![Время](../../../images/icons/toolbar-controls/type-time_default.svg) — для ввода даты/времени, будет вставлена конструкция создания объекта, содержащего текущее дата/время. Пример: `new Date(2020, 1, 5, 13, 12, 50, 100)`.

Логические значения:

* **false** — Ложь;
* **true** — Истина.